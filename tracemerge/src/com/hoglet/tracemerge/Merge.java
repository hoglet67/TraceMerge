package com.hoglet.tracemerge;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Merge {

	// Enough for 2 seconds of 2MHz
	public static final int LENGTH = 4000000;

	// Captures are 8 bits wide
	public static final int WIDTH = 8;

	// Fixed bits
	public static final int RES_BIT = 0;
	public static final int CLK_BIT = 1;

	public void merge(String file, int offset, int[] map, int[] output) throws IOException {
		String line;
		BufferedReader reader = new BufferedReader(new FileReader(file));

		int last[] = new int[WIDTH];
		int bits[] = new int[WIDTH];
		boolean triggered = false;
		int index = offset;
		int res = 0;
		int lastres = 0;

		System.out.println(file);
		while ((line = reader.readLine()) != null) {

			// ; CSV, generated by libsigrok 0.4.0 on Fri Jan 6 11:36:47 2017
			// ; Channels (8/8): nRES, Phi2, SYNC, RnW, D3, D2, D1, D0
			// ; Samplerate: 24 MHz
			// 0,0,0,1,0,0,0,0

			line = line.trim();

			// Skip comments
			if (line.startsWith(";")) {
				continue;
			}

			// Parse the line
			for (int i = 0; i < WIDTH; i++) {
				last[i] = bits[i];
				bits[i] = line.charAt(i * 2) - '0';
			}

			// Sample on falling edge of clock
			if ((bits[CLK_BIT] == 0) && (last[CLK_BIT] == 1)) {

				if (triggered) {
					// Iterate through the sampled bits in order
					for (int i = 0; i < map.length; i++) {
						// Map indicates the bit position for the bit in the
						// output array
						if (map[i] >= 0) {
							// Clear the output bit in position
							output[index] &= ~(1 << map[i]);
							// Or in the required bit
							output[index] |= last[i] << map[i];
						}
					}
					index++;
				} else {
					res = last[RES_BIT];
					if ((lastres == 0) && (res == 1)) {
						// Trigger on rising edge of reset
						System.out.println("triggered");
						triggered = true;
					}					
					lastres = res;					
				}

			}
		}
		reader.close();
	}

	public static final void main(String[] args) {
		try {

			int addr[] = new int[LENGTH];
			int data[] = new int[LENGTH];
			int sync[] = new int[LENGTH];
			int rnw[] = new int[LENGTH];

			Merge c = new Merge();
			c.merge("V2_A15-A12.csv", 1, new int[] { -1, -1,  0, -1, -1, -1, -1, -1 }, sync);
			c.merge("V2_A15-A12.csv", 1, new int[] { -1, -1, -1,  0, -1, -1, -1, -1 }, rnw);
			c.merge("V2_A15-A12.csv", 1, new int[] { -1, -1, -1, -1, 15, 14, 13, 12 }, addr);
			c.merge("V2_A11-A8.csv",  1, new int[] { -1, -1, -1, -1, 11, 10,  9,  8 }, addr);
			c.merge("V2_A7-A4.csv",   1, new int[] { -1, -1, -1, -1,  7,  6,  5,  4 }, addr);
			c.merge("V2_A3-A0.csv",   1, new int[] { -1, -1, -1, -1,  3,  2,  1,  0 }, addr);
			c.merge("V2_D7-D4.csv",   1, new int[] { -1, -1, -1, -1,  7,  6,  5,  4 }, data);
			c.merge("V2_D3-D0.csv",   1, new int[] { -1, -1, -1, -1,  3,  2,  1,  0 }, data);

			for (int i = 0; i < LENGTH; i++) {
				System.out.println(String.format("%d %04X %02X %d", sync[i], addr[i], data[i], rnw[i]));
			}

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
